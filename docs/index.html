<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FTSO Flare Dashboard</title>
  <script src="https://cdn.plot.ly/plotly-2.20.0.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdn.datatables.net/1.13.4/css/jquery.dataTables.min.css">
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdn.datatables.net/1.13.4/js/jquery.dataTables.min.js"></script>
  <style>
    /* Style the DataTables dropdown */
    .dataTables_length select {
      background-color: #1f2937; /* Dark gray background */
      color: #ffffff; /* White text */
      border: 1px solid #374151; /* Border color */
      padding: 4px; /* Add some padding */
      border-radius: 4px; /* Rounded corners */
    }

    /* Style the dropdown options */
    .dataTables_length select option {
      background-color: #1f2937; /* Dark gray background for options */
      color: #ffffff; /* White text for options */
    }

    /* Fix for dropdown menu when opened */
    select:focus {
      outline: none; /* Remove default focus outline */
      box-shadow: 0 0 5px #374151; /* Add a subtle shadow for focus */
    }
  </style>
</head>

<body class="bg-gray-900 text-gray-100 font-sans">
  <header class="text-center py-4 bg-gray-800 border-b border-gray-700 flex items-center justify-center gap-4">
    <img src="assets/logo.png" alt="Dashboard Logo" class="h-12 w-auto" />
    <h1 class="text-2xl font-bold">FTSO Flare Dashboard</h1>
  </header>

  <main class="container mx-auto p-4">
    <!-- Controls -->
    <section class="flex flex-wrap gap-4 mb-6">
      <div class="flex-1 min-w-[200px]">
        <label class="block font-bold mb-2">Max locked voting power (%):</label>
        <input type="number" id="maxVotePowerInput" min="0" max="100" step="0.1" value="100"
          class="w-full p-2 bg-gray-800 border border-gray-700 rounded" />
      </div>
      <div class="flex-1 min-w-[200px]">
        <label class="block font-bold mb-2">
          <input type="checkbox" id="registeredLatestOnly" class="mr-2" />
          Registered in Latest Snapshot Only
        </label>
      </div>
      <div class="flex-1 min-w-[200px]">
        <label class="block font-bold mb-2">
          <input type="checkbox" id="registeredOnly" class="mr-2" />
          Registered at Each Date
        </label>
      </div>
      <div class="flex-1 min-w-[200px]">
        <label for="timeframe" class="block font-bold mb-2">Timeframe:</label>
        <select id="timeframe" class="w-full p-2 bg-gray-800 border border-gray-700 rounded">
          <option value="latest">Latest</option>
          <option value="7-day">7-Day Average</option>
          <option value="30-day">30-Day Average</option>
          <option value="cumulative">Cumulative Average</option>
        </select>
      </div>
    </section>

    <!-- Reward Rate Chart -->
    <section id="chartContainer" class="overflow-x-auto">
      <div id="rewardRateChart" class="w-full h-[400px]"></div>
    </section>

    <!-- Full Data Table -->
    <section>
      <h2 class="text-xl font-bold mt-6">Full Data Table</h2>
      <table id="dataTable" class="display w-full border-collapse mt-4 bg-gray-800 text-gray-100">
        <thead>
          <tr class="bg-gray-700">
            <th class="p-2 border border-gray-600">Date</th>
            <th class="p-2 border border-gray-600">Provider</th>
            <th class="p-2 border border-gray-600">Vote Power %</th>
            <th class="p-2 border border-gray-600">Reward Rate (%)</th>
          </tr>
        </thead>
        <tbody>
          <!-- Rows will be dynamically populated by renderTable() -->
        </tbody>
      </table>
    </section>
  </main>

  <script>
    // Example: Load both Flare and Songbird, transform Songbird fields
    async function loadData() {
      try {
        const res = await fetch('https://api.github.com/repos/tripkane/flare-ftso-snapshot/contents/daily_snapshots');
        const files = await res.json();

        // Flare files
        const flareUrls = files
          .filter(f => f.name.startsWith('flare_') && f.name.endsWith('.json'))
          .map(f => f.download_url);

        // Songbird files
        const songbirdUrls = files
          .filter(f => f.name.startsWith('songbird_') && f.name.endsWith('.json'))
          .map(f => f.download_url);

        // Load Flare data as usual
        const flareData = await Promise.all(flareUrls.map(url => fetch(url).then(r => r.json())));
        const flareSnapshots = flareData.map(s => ({ date: s.date, providers: s.providers }));

        // Load Songbird data and transform fields
        const songbirdData = await Promise.all(songbirdUrls.map(url => fetch(url).then(r => r.json())));
        const songbirdSnapshots = songbirdData.map(s => ({
          date: s.date,
          providers: s.providers.map(p => ({
            SGB_provider: p.name,
            SGB_vote_power_locked_pct: p.vote_power_pct_locked,
            SGB_vote_power_pct: p.vote_power_pct
          }))
        }));

        // Store both sets for filtering
        window.flareSnapshots = flareSnapshots;
        window.songbirdSnapshots = songbirdSnapshots;

        // Continue with your rendering logic...
        // You can now filter and display either or both datasets as needed
      } catch (error) {
        console.error('Error loading data:', error);
        alert('Failed to load data. Please try again later.');
      }
    }

    function getFilteredProviders() {
      const registeredOnly = document.getElementById('registeredOnly').checked;
      const registeredLatestOnly = document.getElementById('registeredLatestOnly').checked;
      let latestSnapshot = window.flareSnapshots[window.flareSnapshots.length - 1];
      let registeredInLatest = new Set();
      if (latestSnapshot) {
        latestSnapshot.providers.forEach(provider => {
          if (provider.registered && provider.registered.toLowerCase() === "yes") {
            registeredInLatest.add(provider.name);
          }
        });
      }

      const providersOverLimit = getProvidersOverLimitCombined();

      const filtered = window.flareSnapshots.flatMap(snapshot =>
        snapshot.providers.filter(provider => {
          if (providersOverLimit.has(provider.name)) return false;
          const isRegistered = provider.registered && provider.registered.toLowerCase() === "yes";
          const isRegisteredLatest = registeredInLatest.has(provider.name);
          if (registeredOnly && !isRegistered) return false;
          if (registeredLatestOnly && !isRegisteredLatest) return false;
          return true;
        }).map(provider => ({
          ...provider,
          date: snapshot.date
        }))
      );
      return filtered;
    }

    function getFilteredSongbirdProviders() {
      const providersOverLimit = getProvidersOverLimitCombined();
      const filtered = window.songbirdSnapshots.flatMap(snapshot =>
        snapshot.providers.filter(provider => {
          if (providersOverLimit.has(provider.SGB_provider)) return false;
          return true;
        }).map(provider => ({
          ...provider,
          date: snapshot.date
        }))
      );
      return filtered;
    }

    function getProvidersOverLimitCombined() {
      const maxVotePower = parseFloat(document.getElementById('maxVotePowerInput').value) || 100;
      const overLimit = new Set();

      // Flare
      window.flareSnapshots.forEach(snapshot => {
        snapshot.providers.forEach(provider => {
          const votePower = parseFloat(provider.vote_power_pct_locked);
          if (votePower > maxVotePower) {
            overLimit.add(provider.name);
          }
        });
      });

      // Songbird
      window.songbirdSnapshots.forEach(snapshot => {
        snapshot.providers.forEach(provider => {
          const votePower = parseFloat(provider.SGB_vote_power_locked_pct);
          if (votePower > maxVotePower) {
            overLimit.add(provider.SGB_provider);
          }
        });
      });

      return overLimit;
    }

    function renderChart() {
      const timeframe = document.getElementById('timeframe').value;
      const filteredProviders = getFilteredProviders();

      const rewardRates = {};
      filteredProviders.forEach(provider => {
        if (!rewardRates[provider.name]) rewardRates[provider.name] = [];
        rewardRates[provider.name].push(parseFloat(provider.reward_rate) || 0);
      });

      let data = Object.keys(rewardRates).map(name => {
        const rates = rewardRates[name];
        let average = 0;

        switch (timeframe) {
          case '7-day':
            average = rates.slice(-7).reduce((sum, rate) => sum + rate, 0) / Math.min(7, rates.length);
            break;
          case '30-day':
            average = rates.slice(-30).reduce((sum, rate) => sum + rate, 0) / Math.min(30, rates.length);
            break;
          case 'cumulative':
            average = rates.reduce((sum, rate) => sum + rate, 0) / rates.length;
            break;
          default:
            average = rates[rates.length - 1];
        }

        return { name, average: average.toFixed(4) }; // Keep raw average to 4 decimal places for precision
      });

      // Sort data by reward rate (highest to lowest)
      data = data.sort((a, b) => b.average - a.average);

      const chartData = {
        x: data.map(d => d.name),
        y: data.map(d => (parseFloat(d.average) * 100).toFixed(2)), // Convert to percentage and format to 2 decimal places
        type: 'bar',
        marker: { color: 'orange' }
      };

      Plotly.newPlot('rewardRateChart', [chartData], {
        title: `Reward Rate (%) - ${timeframe}`,
        xaxis: { title: 'Provider' },
        yaxis: { title: 'Reward Rate (%)' },
        margin: { t: 50, l: 50, r: 50, b: 50 },
        responsive: true
      });
    }

    function renderTable() {
      const tbody = document.getElementById('dataTable').querySelector('tbody');
      tbody.innerHTML = '';

      const filteredProviders = getFilteredProviders();

      filteredProviders.forEach(provider => {
        // Ensure vote_power_pct and reward_rate are properly handled
        const votePower = isNaN(parseFloat(provider.vote_power_pct)) ? 0 : parseFloat(provider.vote_power_pct); // Replace NaN with 0
        const rewardRate = isNaN(parseFloat(provider.reward_rate)) ? 0 : parseFloat(provider.reward_rate) * 100; // Replace NaN with 0 and convert to percentage

        const row = document.createElement('tr');
        row.innerHTML = `
          <td class="p-2 border border-gray-600">${provider.date || 'N/A'}</td> <!-- Handle missing dates -->
          <td class="p-2 border border-gray-600">${provider.name || 'Unknown'}</td> <!-- Handle missing provider names -->
          <td class="p-2 border border-gray-600">${votePower.toFixed(2)}</td>
          <td class="p-2 border border-gray-600">${rewardRate.toFixed(2)}</td>
        `;
        tbody.appendChild(row);
      });

      // Reinitialize DataTables after updating the table
      if ($.fn.DataTable.isDataTable('#dataTable')) {
        $('#dataTable').DataTable().destroy(); // Destroy the existing DataTable instance
      }

      $('#dataTable').DataTable({
        paging: true, // Enable pagination
        searching: true, // Enable global search
        ordering: true, // Enable column sorting
        order: [[3, 'desc']], // Default sort by Reward Rate (%) in descending order
        pageLength: 100, // Default to showing 100 entries
        columnDefs: [
          { targets: 0, type: 'date' }, // Treat Date column as a date
          { targets: 2, type: 'num' }, // Treat Vote Power % as numeric
          { targets: 3, type: 'num' }, // Treat Reward Rate (%) as numeric
        ],
      });
    }

    document.getElementById('maxVotePowerInput').addEventListener('input', () => {
      renderChart();
      renderTable();
    });
    document.getElementById('registeredLatestOnly').addEventListener('change', () => {
      renderChart();
      renderTable();
    });
    document.getElementById('registeredOnly').addEventListener('change', () => {
      renderChart();
      renderTable();
    });
    document.getElementById('timeframe').addEventListener('change', renderChart);

    document.addEventListener('DOMContentLoaded', loadData);
  </script>
</body>

</html>
