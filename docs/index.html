<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FTSO Flare Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.datatables.net/1.13.4/css/jquery.dataTables.min.css">
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdn.datatables.net/1.13.4/js/jquery.dataTables.min.js"></script>
  <style>
    /* Style the DataTables dropdown */
    .dataTables_length select {
      background-color: #1f2937; /* Dark gray background */
      color: #ffffff; /* White text */
      border: 1px solid #374151; /* Border color */
      padding: 4px; /* Add some padding */
      border-radius: 4px; /* Rounded corners */
    }

    /* Style the dropdown options */
    .dataTables_length select option {
      background-color: #1f2937; /* Dark gray background for options */
      color: #ffffff; /* White text for options */
    }

    /* Fix for dropdown menu when opened */
    select:focus {
      outline: none; /* Remove default focus outline */
      box-shadow: 0 0 5px #374151; /* Add a subtle shadow for focus */
    }

    /* Table container for scrolling - let DataTables handle overflow */
    #tableContainer {
      max-height: 600px;
    }

    /* Sticky table headers */
    #dataTable thead th {
      position: sticky;
      top: 0;
      background-color: #374151; /* Same as bg-gray-700 */
      z-index: 10;
    }
  </style>
</head>

<body class="bg-gray-900 text-gray-100 font-sans">
  <header class="py-4 bg-gray-800 border-b border-gray-700 flex items-center justify-between gap-4">
    <div class="flex items-center gap-4">
      <img src="assets/logo.png" alt="Dashboard Logo" class="h-12 w-auto" />
      <h1 class="text-2xl font-bold">FTSO Flare Dashboard</h1>
    </div>
    <!-- The query interface previously posted questions to a local LLM server.
         It is hidden by default because the dashboard now works without any
         backend service. -->
    <div id="queryBar" class="flex items-center space-x-2 hidden">
      <input id="queryInput" type="text" placeholder="Ask about snapshots..." class="p-2 bg-gray-700 border border-gray-600 rounded-l text-sm w-64" />
      <button id="queryButton" class="px-3 py-2 bg-purple-600 text-white rounded-r">Ask</button>
    </div>
  </header>

  <main class="container mx-auto p-4">

    <section id="providerSection" class="border-4 border-gray-700 rounded p-4 mb-4">
      <div class="mb-4">
        <label for="providerFilter" class="font-bold mr-2">Filter Provider:</label>
        <select id="providerFilter" class="p-2 bg-gray-800 border border-gray-700 rounded min-w-[200px]">
          <!-- Options will be populated dynamically -->
        </select>
      </div>
      <div id="singleChartContainer" style="width: 100%;"></div>
      <div id="currentVpChartSection" class="mt-4">
        <div id="currentVpChartContainer" style="width: 100%;"></div>
        <input id="currentVpRange" type="range" min="0" max="0" value="0" class="w-full mt-2" />
      </div>
    </section>

    <!-- Multi-provider chart and table -->
    <section id="multiContainer" class="border-4 border-gray-700 rounded p-4 mb-4">
      <div id="filtersSection" class="flex flex-wrap gap-4 mb-6">
        <div class="flex-1 min-w-[200px]">
          <label class="block font-bold mb-2">Max locked voting power (%):</label>
          <input type="number" id="maxVotePowerInput" min="0" max="100" step="0.1" value="100"
            class="w-full p-2 bg-gray-800 border border-gray-700 rounded" />
      </div>
      <div class="flex-1 min-w-[200px]">
          <label class="block font-bold mb-2">
            <input type="checkbox" id="registeredLatestOnly" class="mr-2" />
            Registered in Latest Snapshot Only
          </label>
        </div>
        <div class="flex-1 min-w-[200px]">
          <label class="block font-bold mb-2">
            <input type="checkbox" id="registeredOnly" class="mr-2" />
            Registered at Each Date
          </label>
        </div>
        <div class="flex-1 min-w-[200px]">
          <label for="timeframe" class="block font-bold mb-2">Timeframe:</label>
          <select id="timeframe" class="w-full p-2 bg-gray-800 border border-gray-700 rounded">
            <option value="latest">Latest</option>
            <option value="7-day">7-Day Average</option>
            <option value="30-day">30-Day Average</option>
            <option value="cumulative">Cumulative Average</option>
          </select>
        </div>
      </div>

      <!-- Reward Rate Chart -->
      <div id="chartContainer" class="overflow-x-auto mb-4">
        <canvas id="rewardRateChart" class="w-full h-[400px]"></canvas>
      </div>
      <div id="multiProviderChartContainer" class="relative overflow-x-auto mb-4">
        <div id="trendChartControls" class="absolute top-0 left-0 bg-gray-800 bg-opacity-80 p-2 rounded text-xs z-10">
          <label for="multiProviderSelect" class="block font-bold mb-1">Compare Providers:</label>
          <select id="multiProviderSelect" multiple size="5" class="mb-2 w-40 p-1 bg-gray-800 border border-gray-700 rounded text-xs"></select>
          <label for="numTopProviders" class="block font-bold mb-1">Top N:</label>
          <input id="numTopProviders" type="number" min="1" value="5" class="mb-2 w-20 p-1 bg-gray-800 border border-gray-700 rounded text-xs" />
          <label for="topKpi" class="block font-bold mb-1">KPI:</label>
          <select id="topKpi" class="w-40 p-1 bg-gray-800 border border-gray-700 rounded text-xs">
            <option value="30-day">30-Day Avg</option>
            <option value="7-day">7-Day Avg</option>
            <option value="cumulative">Cumulative Avg</option>
          </select>
        </div>
        <canvas id="multiProviderChart" class="w-full h-[400px]"></canvas>
      </div>

      <h2 class="text-xl font-bold mt-6">Full Data Table</h2>
      <div id="tableContainer" class="max-h-[600px]">
        <table id="dataTable" class="display w-full border-collapse mt-4 bg-gray-800 text-gray-100">
          <thead>
            <tr class="bg-gray-700">
              <th class="p-2 border border-gray-600">Date</th>
            <th class="p-2 border border-gray-600">Provider</th>
            <th class="p-2 border border-gray-600">Current Voting Power %</th>
            <th class="p-2 border border-gray-600">Locked Voting Power %</th>
            <th class="p-2 border border-gray-600">Current Voting Power % (SGB)</th>
            <th class="p-2 border border-gray-600">Locked Voting Power % (SGB)</th>
            <th class="p-2 border border-gray-600">Reward Rate (%)</th>
            <th class="p-2 border border-gray-600">7-Day Avg Reward Rate (%)</th>
            <th class="p-2 border border-gray-600">30-Day Avg Reward Rate (%)</th>
            <th class="p-2 border border-gray-600">Cumulative Avg Reward Rate (%)</th>
            <th class="p-2 border border-gray-600">Headroom (%)</th>
            <th class="p-2 border border-gray-600">Trend Slope</th>
            <th class="p-2 border border-gray-600">Reward Volatility (%)</th>
          </tr>
        </thead>
        <tbody>
          <!-- Rows will be dynamically populated by renderTable() -->
        </tbody>
        </table>
      </div>
    </section>

    <div id="miniChartsContainer" style="overflow-y: auto; max-height: 1200px; width: 100%;">
      <!-- Mini charts will be injected here -->
    </div>
  </main>

  <script>

    let rewardChart;
    let singleVoteChart;
    let singleRewardChart;
    let currentVoteChart;
    let dataTable;
    let multiProviderChart;

    // Base URL for fetching snapshot files directly from GitHub
    const BASE_URL = 'https://raw.githubusercontent.com/tripkane/flare-ftso-snapshot/main/docs';

    // Small debounce utility
    function debounce(func, delay) {
      let timeout;
      return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), delay);
      };
    }


    // Example: Load both Flare and Songbird, transform Songbird fields
    async function loadData() {
      try {
        const manifestRes = await fetch(`${BASE_URL}/daily_snapshots/manifest.json`);
        const manifest = await manifestRes.json();

        const flareUrls = manifest.flare.map(name => `${BASE_URL}/daily_snapshots/${name}`);
        const songbirdUrls = manifest.songbird.map(name => `${BASE_URL}/daily_snapshots/${name}`);

        const flareData = await Promise.all(flareUrls.map(url => fetch(url).then(r => r.json())));
        const flareSnapshots = flareData.map(s => ({ date: s.date, providers: s.providers }));

        const songbirdData = await Promise.all(songbirdUrls.map(url => fetch(url).then(r => r.json())));
        const songbirdSnapshots = songbirdData.map(s => ({
          date: s.date,
          providers: s.providers.map(p => ({
            SGB_provider: p.name,
            SGB_vote_power_locked_pct: p.vote_power_pct_locked,
            SGB_vote_power_pct: p.vote_power_pct
          }))
        }));

        let currentManifest = { flare: [], songbird: [] };
        try {
          const currentRes = await fetch(`${BASE_URL}/current_vote_power/manifest.json`);
          currentManifest = await currentRes.json();
        } catch (err) {
          console.warn('No current vote power manifest found');
        }
        const flareCurrentUrls = currentManifest.flare.map(path => `${BASE_URL}/current_vote_power/${path}`);
        const flareCurrentData = await Promise.all(flareCurrentUrls.map(u => fetch(u).then(r => r.json())));
        const flareCurrentSnapshots = flareCurrentData.map(s => ({ timestamp: s.timestamp, providers: s.providers }));

        const songbirdCurrentUrls = currentManifest.songbird.map(path => `${BASE_URL}/current_vote_power/${path}`);
        const songbirdCurrentData = await Promise.all(songbirdCurrentUrls.map(u => fetch(u).then(r => r.json())));
        const songbirdCurrentSnapshots = songbirdCurrentData.map(s => ({ timestamp: s.timestamp, providers: s.providers }));

        window.flareSnapshots = flareSnapshots;
        window.songbirdSnapshots = songbirdSnapshots;
        window.flareCurrentSnapshots = flareCurrentSnapshots;
        window.songbirdCurrentSnapshots = songbirdCurrentSnapshots;
        computeProviderStats();
      } catch (error) {
        console.error('Error loading data:', error);
        alert('Failed to load data. Please try again later.');
      }
    }

    let providerStats = {};

    function computeProviderStats() {
      const stats = {};
      const latest = window.flareSnapshots[window.flareSnapshots.length - 1];
      const lockedMap = {};
      if (latest) {
        latest.providers.forEach(p => {
          lockedMap[p.name] = parseFloat(p.vote_power_pct_locked);
        });
      }

      window.flareSnapshots.forEach(snap => {
        snap.providers.forEach(p => {
          const name = p.name;
          if (!stats[name]) {
            stats[name] = { rewardRates: [], locked: lockedMap[name] || 0 };
          }
          stats[name].rewardRates.push({ date: snap.date, rate: parseFloat(p.reward_rate) || 0 });
        });
      });

      Object.keys(stats).forEach(name => {
        const arr = stats[name].rewardRates.map(r => r.rate);
        const n = arr.length;
        const avg7 = arr.slice(-7).reduce((s, r) => s + r, 0) / Math.min(7, n);
        const avg30 = arr.slice(-30).reduce((s, r) => s + r, 0) / Math.min(30, n);
        const avgCum = arr.reduce((s, r) => s + r, 0) / n;
        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
        arr.forEach((y, i) => {
          const x = i + 1;
          sumX += x;
          sumY += y;
          sumXY += x * y;
          sumX2 += x * x;
        });
        const slope = n > 1 ? (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX) : 0;
        const avg = sumY / n || 0;
        const variance = arr.reduce((acc, r) => acc + Math.pow(r - avg, 2), 0) / n || 0;
        const stddev = Math.sqrt(variance);
        stats[name].trend = slope;
        stats[name].volatility = stddev;
        stats[name].avg7 = avg7;
        stats[name].avg30 = avg30;
        stats[name].avgCum = avgCum;
      });

      const vpData = {};
      window.flareCurrentSnapshots.forEach(snap => {
        snap.providers.forEach(p => {
          if (!vpData[p.name]) vpData[p.name] = [];
          vpData[p.name].push(parseFloat(p.vote_power_pct));
        });
      });

      Object.keys(vpData).forEach(name => {
        const arr = vpData[name];
        const n = arr.length;
        const current = arr[n - 1];
        let slope = 0;
        if (n > 1) {
          let sx = 0, sy = 0, sxy = 0, sx2 = 0;
          arr.forEach((y, i) => {
            const x = i;
            sx += x;
            sy += y;
            sxy += x * y;
            sx2 += x * x;
          });
          slope = (n * sxy - sx * sy) / (n * sx2 - sx * sx);
        }
        const projection = current + slope * 6;
        const locked = stats[name] ? stats[name].locked : 0;
        if (stats[name]) {
          stats[name].headroom = locked - projection;
        }
      });

      providerStats = stats;

      const multiSelect = document.getElementById('multiProviderSelect');
      const names = Object.keys(stats).sort();
      multiSelect.innerHTML = names.map(n => `<option value="${n}">${n}</option>`).join('');
      updateTopProviders();
    }

    function updateTopProviders() {
      const kpi = document.getElementById('topKpi').value;
      const num = parseInt(document.getElementById('numTopProviders').value) || 5;
      const names = Object.keys(providerStats);
      const sorted = names.sort((a, b) => {
        const getAvg = (name) => {
          switch (kpi) {
            case '7-day':
              return providerStats[name].avg7 || 0;
            case 'cumulative':
              return providerStats[name].avgCum || 0;
            default:
              return providerStats[name].avg30 || 0;
          }
        };
        return getAvg(b) - getAvg(a);
      });

      const top = sorted.slice(0, num);
      const select = document.getElementById('multiProviderSelect');
      Array.from(select.options).forEach(opt => {
        opt.selected = top.includes(opt.value);
      });
      renderMultiProviderChart();
    }

    function getFilteredProviders() {
      const registeredOnly = document.getElementById('registeredOnly').checked;
      const registeredLatestOnly = document.getElementById('registeredLatestOnly').checked;
      let latestSnapshot = window.flareSnapshots[window.flareSnapshots.length - 1];
      let registeredInLatest = new Set();
      if (latestSnapshot) {
        latestSnapshot.providers.forEach(provider => {
          if (provider.registered && provider.registered.toLowerCase() === "yes") {
            registeredInLatest.add(provider.name);
          }
        });
      }

      const providersOverLimit = getProvidersOverLimitCombined();

      const filtered = window.flareSnapshots.flatMap(snapshot =>
        snapshot.providers.filter(provider => {
          if (providersOverLimit.has(provider.name)) return false;
          const isRegistered = provider.registered && provider.registered.toLowerCase() === "yes";
          const isRegisteredLatest = registeredInLatest.has(provider.name);
          if (registeredOnly && !isRegistered) return false;
          if (registeredLatestOnly && !isRegisteredLatest) return false;
          return true;
        }).map(provider => ({
          ...provider,
          date: snapshot.date
        }))
      );
      return filtered;
    }

    function getFilteredSongbirdProviders() {
      const providersOverLimit = getProvidersOverLimitCombined();
      const filtered = window.songbirdSnapshots.flatMap(snapshot =>
        snapshot.providers.filter(provider => {
          if (providersOverLimit.has(provider.SGB_provider)) return false;
          return true;
        }).map(provider => ({
          ...provider,
          date: snapshot.date
        }))
      );
      return filtered;
    }

    function getProvidersOverLimitCombined() {
      const maxVotePower = parseFloat(document.getElementById('maxVotePowerInput').value) || 100;
      const overLimit = new Set();

      // Flare
      window.flareSnapshots.forEach(snapshot => {
        snapshot.providers.forEach(provider => {
          const votePower = parseFloat(provider.vote_power_pct_locked);
          if (votePower > maxVotePower) {
            overLimit.add(provider.name);
          }
        });
      });

      // Songbird
      window.songbirdSnapshots.forEach(snapshot => {
        snapshot.providers.forEach(provider => {
          const votePower = parseFloat(provider.SGB_vote_power_locked_pct);
          if (votePower > maxVotePower) {
            overLimit.add(provider.SGB_provider);
          }
        });
      });

      return overLimit;
    }

    function renderChart() {
      const timeframe = document.getElementById('timeframe').value;
      const filteredProviders = getFilteredProviders();

      const rewardRates = {};
      filteredProviders.forEach(provider => {
        if (!rewardRates[provider.name]) rewardRates[provider.name] = [];
        rewardRates[provider.name].push(parseFloat(provider.reward_rate) || 0);
      });

      let data = Object.keys(rewardRates).map(name => {
        const rates = rewardRates[name];
        let average = 0;

        switch (timeframe) {
          case '7-day':
            average = rates.slice(-7).reduce((sum, rate) => sum + rate, 0) / Math.min(7, rates.length);
            break;
          case '30-day':
            average = rates.slice(-30).reduce((sum, rate) => sum + rate, 0) / Math.min(30, rates.length);
            break;
          case 'cumulative':
            average = rates.reduce((sum, rate) => sum + rate, 0) / rates.length;
            break;
          default:
            average = rates[rates.length - 1];
        }

        return { name, average: average.toFixed(4) }; // Keep raw average to 4 decimal places for precision
      });

      // Sort data by reward rate (highest to lowest)
      data = data.sort((a, b) => b.average - a.average);

      const ctx = document.getElementById('rewardRateChart').getContext('2d');
      const labels = data.map(d => d.name);
      const values = data.map(d => parseFloat(d.average) * 100);

      if (rewardChart) rewardChart.destroy();

      rewardChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels,
          datasets: [{
            label: 'Reward Rate (%)',
            data: values,
            backgroundColor: 'purple'
          }]
        },
        options: {
          responsive: true,
          plugins: {
            title: { display: true, text: `Flare Reward Rate - ${timeframe}` },
            legend: { display: false }
          },
          scales: {
            x: { ticks: { maxRotation: 45, minRotation: 45 }, title: { display: true, text: 'Provider' } },
            y: { title: { display: true, text: 'Reward Rate (%)' } }
          }
        }
      });
    }

    function renderTable() {
      const table = $('#dataTable');
      const tbody = table.find('tbody');
      tbody.empty();

      // Get filtered Flare and Songbird providers
      const filteredFlare = getFilteredProviders();
      const filteredSongbird = getFilteredSongbirdProviders();

      // Build a lookup for SGB: {date|provider: providerObj}
      const sgbMap = {};
      filteredSongbird.forEach(provider => {
        const key = `${provider.date}|${provider.SGB_provider}`;
        sgbMap[key] = provider;
      });

      // Compute reward rate averages per provider
      const rewardMap = {};
      filteredFlare.forEach(p => {
        if (!rewardMap[p.name]) rewardMap[p.name] = [];
        rewardMap[p.name].push(parseFloat(p.reward_rate) || 0);
      });
      const avgMap = {};
      Object.keys(rewardMap).forEach(name => {
        const rates = rewardMap[name];
        const avg7 = rates.slice(-7).reduce((s, r) => s + r, 0) / Math.min(7, rates.length);
        const avg30 = rates.slice(-30).reduce((s, r) => s + r, 0) / Math.min(30, rates.length);
        const avgCum = rates.reduce((s, r) => s + r, 0) / rates.length;
        avgMap[name] = { avg7: avg7 * 100, avg30: avg30 * 100, avgCum: avgCum * 100 };
      });

      // Only iterate Flare providers (left join)
      filteredFlare.forEach(provider => {
        const key = `${provider.date}|${provider.name}`;
        const sgb = sgbMap[key];

        const tr = document.createElement('tr');
        const avg = avgMap[provider.name] || { avg7: '', avg30: '', avgCum: '' };
        const stats = providerStats[provider.name] || {};
        tr.innerHTML = `
          <td class="p-2 border border-gray-600">${provider.date}</td>
          <td class="p-2 border border-gray-600">${provider.name}</td>
          <td class="p-2 border border-gray-600">${provider.vote_power_pct !== undefined && provider.vote_power_pct !== '' ? Number(provider.vote_power_pct).toFixed(2) : ''}</td>
          <td class="p-2 border border-gray-600">${provider.vote_power_pct_locked !== undefined && provider.vote_power_pct_locked !== '' ? Number(provider.vote_power_pct_locked).toFixed(2) : ''}</td>
          <td class="p-2 border border-gray-600">${sgb && sgb.SGB_vote_power_pct !== undefined && sgb.SGB_vote_power_pct !== '' ? Number(sgb.SGB_vote_power_pct).toFixed(2) : ''}</td>
          <td class="p-2 border border-gray-600">${sgb && sgb.SGB_vote_power_locked_pct !== undefined && sgb.SGB_vote_power_locked_pct !== '' ? Number(sgb.SGB_vote_power_locked_pct).toFixed(2) : ''}</td>
          <td class="p-2 border border-gray-600">${provider.reward_rate !== undefined && provider.reward_rate !== '' ? Number(provider.reward_rate * 100).toFixed(2) : ''}</td>
          <td class="p-2 border border-gray-600">${avg.avg7 !== '' ? avg.avg7.toFixed(2) : ''}</td>
          <td class="p-2 border border-gray-600">${avg.avg30 !== '' ? avg.avg30.toFixed(2) : ''}</td>
          <td class="p-2 border border-gray-600">${avg.avgCum !== '' ? avg.avgCum.toFixed(2) : ''}</td>
          <td class="p-2 border border-gray-600">${stats.headroom !== undefined ? stats.headroom.toFixed(2) : ''}</td>
          <td class="p-2 border border-gray-600">${stats.trend !== undefined ? stats.trend.toFixed(4) : ''}</td>
          <td class="p-2 border border-gray-600">${stats.volatility !== undefined ? (stats.volatility * 100).toFixed(2) : ''}</td>
        `;
        tbody.append(tr);
      });

      const rows = tbody.find('tr');

      if (dataTable) {
        dataTable.clear();
        dataTable.rows.add(rows);
        dataTable.draw();
      } else {
        dataTable = table.DataTable({
          paging: true,
          searching: true,
          ordering: true,
          order: [[0, 'desc'], [1, 'asc']],
          pageLength: 100,
          scrollY: '500px',
          scrollX: true,
          scrollCollapse: true,
          columnDefs: [
            { targets: 0, type: 'date' },
            { targets: [2,3,4,5,6,7,8,9,10,11,12], type: 'num' },
          ],
        });
      }
    }

    function renderSingleProviderChart() {
      const filteredFlare = getFilteredProviders();
      const filteredSongbird = getFilteredSongbirdProviders();

      // Build provider map
      const providerMap = {};
      filteredFlare.forEach(p => {
        if (!providerMap[p.name]) providerMap[p.name] = { flare: [], songbird: [] };
        providerMap[p.name].flare.push(p);
      });
      filteredSongbird.forEach(p => {
        if (!providerMap[p.SGB_provider]) providerMap[p.SGB_provider] = providerMap[p.SGB_provider] || { flare: [], songbird: [] };
        providerMap[p.SGB_provider].songbird.push(p);
      });

      // Sort by reward rate (highest to lowest)
      const sortedProviders = Object.keys(providerMap).sort((a, b) => {
        const aReward = providerMap[a].flare.concat(providerMap[a].songbird).slice(-1)[0]?.reward_rate || 0;
        const bReward = providerMap[b].flare.concat(providerMap[b].songbird).slice(-1)[0]?.reward_rate || 0;
        return bReward - aReward;
      });

      const providerFilter = document.getElementById('providerFilter');
      const currentValue = providerFilter.value;
      providerFilter.innerHTML = sortedProviders.map(name => `<option value="${name}">${name}</option>`).join('');
      if (!sortedProviders.includes(currentValue)) {
        providerFilter.value = sortedProviders[0] || '';
      } else {
        providerFilter.value = currentValue;
      }
      const selectedProvider = providerFilter.value;

      const flareData = providerMap[selectedProvider]?.flare || [];
      const songbirdData = providerMap[selectedProvider]?.songbird || [];
      const dates = [...new Set(flareData.map(d => d.date).concat(songbirdData.map(d => d.date)))].sort();
      const flareLocked = dates.map(date => {
        const val = flareData.find(d => d.date === date)?.vote_power_pct_locked;
        return val !== undefined && val !== null ? Number(val) : null;
      });
      const sgbLocked = dates.map(date => {
        const val = songbirdData.find(d => d.date === date)?.SGB_vote_power_locked_pct;
        return val !== undefined && val !== null ? Number(val) : null;
      });
      const sgbCurrent = dates.map(date => {
        const val = songbirdData.find(d => d.date === date)?.SGB_vote_power_pct;
        return val !== undefined && val !== null ? Number(val) : null;
      });
      const rewardRate = dates.map(date => {
        const val = flareData.find(d => d.date === date)?.reward_rate;
        return val !== undefined && val !== null ? Number(val) * 100 : null;
      });
      const registered = dates.map(date => {
        const reg = flareData.find(d => d.date === date)?.registered;
        return reg && reg.toLowerCase() === "yes" ? 1 : 0;
      });

        const container = document.getElementById('singleChartContainer');
        container.innerHTML = '';
        const voteHeader = document.createElement('h3');
        voteHeader.textContent = 'Network Voting Power';
        voteHeader.className = 'text-lg font-bold mb-2';
        const voteCanvas = document.createElement('canvas');
        const rewardHeader = document.createElement('h3');
        rewardHeader.textContent = 'Flare Reward Rate';
        rewardHeader.className = 'text-lg font-bold mb-2 mt-4';
        const rewardCanvas = document.createElement('canvas');
      voteCanvas.style.width = '100%';
      voteCanvas.style.height = '350px';
      voteCanvas.style.marginBottom = '30px';
      rewardCanvas.style.width = '100%';
      rewardCanvas.style.height = '350px';
      rewardCanvas.style.marginBottom = '30px';
      container.appendChild(voteHeader);
      container.appendChild(voteCanvas);
      container.appendChild(rewardHeader);
      container.appendChild(rewardCanvas);

        if (singleVoteChart) singleVoteChart.destroy();
        if (singleRewardChart) singleRewardChart.destroy();

        const voteValues = flareLocked
          .concat(sgbLocked)
          .filter(v => v !== null && !isNaN(v));
        const yAxisMaxValue = Math.max(...voteValues);
        let yAxisMax = isFinite(yAxisMaxValue) ? yAxisMaxValue : 5;
        yAxisMax *= 1.1; // small padding for clarity
        const nearThreshold = voteValues.some(v => Math.abs(v - 2.5) < 0.25);

      singleVoteChart = new Chart(voteCanvas.getContext('2d'), {
        data: {
          labels: dates,
          datasets: (() => {
              const datasets = [
                { label: 'FLR Locked Voting Power', data: flareLocked, borderColor: 'orange', backgroundColor: 'orange', fill: false, type: 'line' },
                { label: 'SGB Locked Voting Power', data: sgbLocked, borderColor: 'blue', backgroundColor: 'blue', fill: false, type: 'line' }
              ];
            if (nearThreshold) {
              datasets.push({ label: '2.5% Threshold', data: Array(dates.length).fill(2.5), borderColor: 'grey', borderDash: [5,5], fill: false, type: 'line' });
            }
            datasets.push(
              { label: 'Registered', data: registered.map(r => r ? yAxisMax : 0), backgroundColor: 'rgba(0,255,0,0.15)', type: 'bar', stack: 'registration', borderWidth: 0, order: -1, barPercentage: 1, categoryPercentage: 1 },
              { label: 'Not Registered', data: registered.map(r => r ? 0 : yAxisMax), backgroundColor: 'rgba(255,0,0,0.15)', type: 'bar', stack: 'registration', borderWidth: 0, order: -1, barPercentage: 1, categoryPercentage: 1 }
            );
            return datasets;
          })()
       },
       options: {
         responsive: true,
          plugins: {
            title: { display: true, text: selectedProvider + ' - Network Voting Power' },
            legend: { position: 'top' }
          },
          scales: {
            x: { title: { display: true, text: 'Date' } },
            y: { title: { display: true, text: 'Voting Power (%)' }, min: 0, max: yAxisMax }
          }
        }
      });

      singleRewardChart = new Chart(rewardCanvas.getContext('2d'), {
        type: 'line',
        data: {
          labels: dates,
          datasets: [
            { label: 'Reward Rate (%)', data: rewardRate, borderColor: 'purple', backgroundColor: 'purple', fill: false }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            title: { display: true, text: selectedProvider + ' - Flare Reward Rate' },
            legend: { display: false }
          },
          scales: {
            x: { title: { display: true, text: 'Date' } },
            y: { title: { display: true, text: 'Reward Rate (%)' } }
          }
        }
      });

      const legendDiv = document.getElementById('masterLegend') || document.createElement('div');
      legendDiv.id = 'masterLegend';
      legendDiv.innerHTML = `
        <div class="flex gap-4 mb-2">
          <span><span style="color:orange;">&#9632;</span> FLR Locked Voting Power</span>
          <span><span style="color:blue;">&#9632;</span> SGB Locked Voting Power</span>
          <span><span style="color:purple;">&#9632;</span> Reward Rate</span>
          ${nearThreshold ? '<span><span style="color:grey;">&#9632;</span> 2.5% Threshold</span>' : ''}
          <span><span style="color:green;">&#11044;</span> Registered</span>
          <span><span style="color:red;">&#11044;</span> Not Registered</span>
        </div>`;
      if (!document.getElementById('masterLegend')) {
        container.parentNode.insertBefore(legendDiv, container);
      }
    }

    function renderMultiProviderChart() {
      const select = document.getElementById('multiProviderSelect');
      const selected = Array.from(select.selectedOptions).map(o => o.value);
      const dates = window.flareSnapshots.map(s => s.date);
      const datasets = selected.map((name, idx) => {
        const colors = ['orange', 'blue', 'purple', 'green', 'red', 'yellow', 'cyan', 'magenta', 'lime', 'teal'];
        const data = dates.map(d => {
          const snap = window.flareSnapshots.find(s => s.date === d);
          const p = snap?.providers.find(pr => pr.name === name);
          return p ? parseFloat(p.reward_rate) * 100 : null;
        });
        return { label: name, data, borderColor: colors[idx % colors.length], backgroundColor: colors[idx % colors.length], fill: false };
      });
      const ctx = document.getElementById('multiProviderChart').getContext('2d');
      if (multiProviderChart) multiProviderChart.destroy();
      multiProviderChart = new Chart(ctx, {
        type: 'line',
        data: { labels: dates, datasets },
        options: {
          responsive: true,
          plugins: { title: { display: true, text: 'Reward Rate Trends' } },
          scales: { x: { title: { display: true, text: 'Date' } }, y: { title: { display: true, text: 'Reward Rate (%)' } } }
        }
      });
    }

    function renderCurrentVoteChart() {
      if (!window.flareCurrentSnapshots && !window.songbirdCurrentSnapshots) return;
      const provider = document.getElementById('providerFilter').value;
      const container = document.getElementById('currentVpChartContainer');
      const range = document.getElementById('currentVpRange');
      container.innerHTML = '';
      const canvas = document.createElement('canvas');
      container.appendChild(canvas);

      const timestampsSet = new Set();
      const flareMap = {};
      if (window.flareCurrentSnapshots) {
        window.flareCurrentSnapshots.forEach(s => {
          timestampsSet.add(s.timestamp);
          const p = s.providers.find(pr => pr.name === provider);
          if (p) flareMap[s.timestamp] = Number(p.vote_power_pct);
        });
      }
      const songbirdMap = {};
      if (window.songbirdCurrentSnapshots) {
        window.songbirdCurrentSnapshots.forEach(s => {
          timestampsSet.add(s.timestamp);
          const p = s.providers.find(pr => pr.name === provider);
          if (p) songbirdMap[s.timestamp] = Number(p.vote_power_pct);
        });
      }

      const timestamps = Array.from(timestampsSet).sort();
      const flareValues = timestamps.map(t => flareMap[t] ?? null);
      const sgbValues = timestamps.map(t => songbirdMap[t] ?? null);

      range.max = Math.max(timestamps.length - 1, 0);
      if (!range.value) range.value = Math.max(timestamps.length - 100, 0);

      function updateCurrentChart() {
        const start = parseInt(range.value) || 0;
        const labels = timestamps.slice(start);
        const flareData = flareValues.slice(start);
        const sgbData = sgbValues.slice(start);

        if (currentVoteChart) currentVoteChart.destroy();

        currentVoteChart = new Chart(canvas.getContext('2d'), {
          type: 'line',
          data: {
            labels,
            datasets: [
              {
                label: 'Flare Current VP',
                data: flareData,
                borderColor: 'orange',
                backgroundColor: 'orange',
                fill: false,
                pointRadius: 0,
                pointHoverRadius: 3,
                spanGaps: true
              },
              {
                label: 'Songbird Current VP',
                data: sgbData,
                borderColor: 'blue',
                backgroundColor: 'blue',
                fill: false,
                pointRadius: 0,
                pointHoverRadius: 3,
                spanGaps: true
              }
            ]
          },
          options: {
            responsive: true,
            interaction: { intersect: false, mode: 'index' },
            plugins: {
              title: { display: true, text: provider + ' - Current Vote Power' },
              tooltip: {
                callbacks: {
                  title: ctx => ctx[0].label,
                  label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y}%`
                }
              }
            },
            scales: {
              x: {
                title: { display: true, text: 'Time' },
                ticks: {
                  autoSkip: false,
                  maxRotation: 0,
                  minRotation: 0,
                  callback: function (value, index) {
                    const label = labels[index];
                    const date = label.slice(0, 10);
                    if (index === 0) return date;
                    const prevDate = labels[index - 1].slice(0, 10);
                    return date !== prevDate ? date : '';
                  }
                }
              },
              y: { title: { display: true, text: 'Vote Power (%)' } }
            }
          }
        });
      }

      range.oninput = updateCurrentChart;
      updateCurrentChart();
    }

    const debouncedRenderChart = debounce(renderChart, 300);
    const debouncedRenderTable = debounce(renderTable, 300);

    // Remove any previous event listeners to avoid duplicates
    const providerFilter = document.getElementById('providerFilter');
    const newProviderFilter = providerFilter.cloneNode(true);
    providerFilter.parentNode.replaceChild(newProviderFilter, providerFilter);
    newProviderFilter.addEventListener('change', function () {
      renderSingleProviderChart();
      renderCurrentVoteChart();
    });

    document.getElementById('maxVotePowerInput').addEventListener('input', () => {
      debouncedRenderChart();
      debouncedRenderTable();
    });
    document.getElementById('registeredLatestOnly').addEventListener('change', () => {
      debouncedRenderChart();
      debouncedRenderTable();
    });
    document.getElementById('registeredOnly').addEventListener('change', () => {
      debouncedRenderChart();
      debouncedRenderTable();
    });
    document.getElementById('timeframe').addEventListener('change', debouncedRenderChart);
    document.getElementById('multiProviderSelect').addEventListener('change', renderMultiProviderChart);
    document.getElementById('numTopProviders').addEventListener('input', updateTopProviders);
    document.getElementById('topKpi').addEventListener('change', updateTopProviders);

    // Query functionality disabled when no LLM backend is used.
    async function sendQuery() {
      alert('Query service not available.');
    }

    document.getElementById('queryButton').addEventListener('click', sendQuery);

    document.addEventListener('DOMContentLoaded', () => {
      loadData().then(() => {
        renderChart();
        renderTable();
        renderSingleProviderChart();
        renderCurrentVoteChart();
        renderMultiProviderChart();
        document.getElementById('providerFilter').addEventListener('change', renderSingleProviderChart);
        document.getElementById('providerFilter').addEventListener('change', renderCurrentVoteChart);
      });
    });
  </script>
</body>

</html>
